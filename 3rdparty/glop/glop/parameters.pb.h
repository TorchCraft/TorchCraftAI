// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/glop/parameters.proto

#ifndef PROTOBUF_ortools_2fglop_2fparameters_2eproto__INCLUDED
#define PROTOBUF_ortools_2fglop_2fparameters_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>


#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_ortools_2fglop_2fparameters_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsGlopParametersImpl();
void InitDefaultsGlopParameters();
inline void InitDefaults() {
  InitDefaultsGlopParameters();
}
}  // namespace protobuf_ortools_2fglop_2fparameters_2eproto
namespace operations_research {
namespace glop {
class GlopParameters;
class GlopParametersDefaultTypeInternal;
extern GlopParametersDefaultTypeInternal _GlopParameters_default_instance_;
}  // namespace glop
}  // namespace operations_research
namespace operations_research {
namespace glop {

enum GlopParameters_ScalingAlgorithm {
  GlopParameters_ScalingAlgorithm_DEFAULT = 0,
  GlopParameters_ScalingAlgorithm_EQUILIBRATION = 1,
  GlopParameters_ScalingAlgorithm_LINEAR_PROGRAM = 2
};
bool GlopParameters_ScalingAlgorithm_IsValid(int value);
const GlopParameters_ScalingAlgorithm GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MIN = GlopParameters_ScalingAlgorithm_DEFAULT;
const GlopParameters_ScalingAlgorithm GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MAX = GlopParameters_ScalingAlgorithm_LINEAR_PROGRAM;
const int GlopParameters_ScalingAlgorithm_ScalingAlgorithm_ARRAYSIZE = GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* GlopParameters_ScalingAlgorithm_descriptor();
inline const ::std::string& GlopParameters_ScalingAlgorithm_Name(GlopParameters_ScalingAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    GlopParameters_ScalingAlgorithm_descriptor(), value);
}
inline bool GlopParameters_ScalingAlgorithm_Parse(
    const ::std::string& name, GlopParameters_ScalingAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlopParameters_ScalingAlgorithm>(
    GlopParameters_ScalingAlgorithm_descriptor(), name, value);
}
enum GlopParameters_SolverBehavior {
  GlopParameters_SolverBehavior_ALWAYS_DO = 0,
  GlopParameters_SolverBehavior_NEVER_DO = 1,
  GlopParameters_SolverBehavior_LET_SOLVER_DECIDE = 2
};
bool GlopParameters_SolverBehavior_IsValid(int value);
const GlopParameters_SolverBehavior GlopParameters_SolverBehavior_SolverBehavior_MIN = GlopParameters_SolverBehavior_ALWAYS_DO;
const GlopParameters_SolverBehavior GlopParameters_SolverBehavior_SolverBehavior_MAX = GlopParameters_SolverBehavior_LET_SOLVER_DECIDE;
const int GlopParameters_SolverBehavior_SolverBehavior_ARRAYSIZE = GlopParameters_SolverBehavior_SolverBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* GlopParameters_SolverBehavior_descriptor();
inline const ::std::string& GlopParameters_SolverBehavior_Name(GlopParameters_SolverBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    GlopParameters_SolverBehavior_descriptor(), value);
}
inline bool GlopParameters_SolverBehavior_Parse(
    const ::std::string& name, GlopParameters_SolverBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlopParameters_SolverBehavior>(
    GlopParameters_SolverBehavior_descriptor(), name, value);
}
enum GlopParameters_PricingRule {
  GlopParameters_PricingRule_DANTZIG = 0,
  GlopParameters_PricingRule_STEEPEST_EDGE = 1,
  GlopParameters_PricingRule_DEVEX = 2
};
bool GlopParameters_PricingRule_IsValid(int value);
const GlopParameters_PricingRule GlopParameters_PricingRule_PricingRule_MIN = GlopParameters_PricingRule_DANTZIG;
const GlopParameters_PricingRule GlopParameters_PricingRule_PricingRule_MAX = GlopParameters_PricingRule_DEVEX;
const int GlopParameters_PricingRule_PricingRule_ARRAYSIZE = GlopParameters_PricingRule_PricingRule_MAX + 1;

const ::google::protobuf::EnumDescriptor* GlopParameters_PricingRule_descriptor();
inline const ::std::string& GlopParameters_PricingRule_Name(GlopParameters_PricingRule value) {
  return ::google::protobuf::internal::NameOfEnum(
    GlopParameters_PricingRule_descriptor(), value);
}
inline bool GlopParameters_PricingRule_Parse(
    const ::std::string& name, GlopParameters_PricingRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlopParameters_PricingRule>(
    GlopParameters_PricingRule_descriptor(), name, value);
}
enum GlopParameters_InitialBasisHeuristic {
  GlopParameters_InitialBasisHeuristic_NONE = 0,
  GlopParameters_InitialBasisHeuristic_BIXBY = 1,
  GlopParameters_InitialBasisHeuristic_TRIANGULAR = 2
};
bool GlopParameters_InitialBasisHeuristic_IsValid(int value);
const GlopParameters_InitialBasisHeuristic GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MIN = GlopParameters_InitialBasisHeuristic_NONE;
const GlopParameters_InitialBasisHeuristic GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MAX = GlopParameters_InitialBasisHeuristic_TRIANGULAR;
const int GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_ARRAYSIZE = GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MAX + 1;

const ::google::protobuf::EnumDescriptor* GlopParameters_InitialBasisHeuristic_descriptor();
inline const ::std::string& GlopParameters_InitialBasisHeuristic_Name(GlopParameters_InitialBasisHeuristic value) {
  return ::google::protobuf::internal::NameOfEnum(
    GlopParameters_InitialBasisHeuristic_descriptor(), value);
}
inline bool GlopParameters_InitialBasisHeuristic_Parse(
    const ::std::string& name, GlopParameters_InitialBasisHeuristic* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlopParameters_InitialBasisHeuristic>(
    GlopParameters_InitialBasisHeuristic_descriptor(), name, value);
}
// ===================================================================

class GlopParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.glop.GlopParameters) */ {
 public:
  GlopParameters();
  virtual ~GlopParameters();

  GlopParameters(const GlopParameters& from);

  inline GlopParameters& operator=(const GlopParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GlopParameters(GlopParameters&& from) noexcept
    : GlopParameters() {
    *this = ::std::move(from);
  }

  inline GlopParameters& operator=(GlopParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlopParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlopParameters* internal_default_instance() {
    return reinterpret_cast<const GlopParameters*>(
               &_GlopParameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GlopParameters* other);
  friend void swap(GlopParameters& a, GlopParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GlopParameters* New() const PROTOBUF_FINAL { return New(NULL); }

  GlopParameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GlopParameters& from);
  void MergeFrom(const GlopParameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GlopParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GlopParameters_ScalingAlgorithm ScalingAlgorithm;
  static const ScalingAlgorithm DEFAULT =
    GlopParameters_ScalingAlgorithm_DEFAULT;
  static const ScalingAlgorithm EQUILIBRATION =
    GlopParameters_ScalingAlgorithm_EQUILIBRATION;
  static const ScalingAlgorithm LINEAR_PROGRAM =
    GlopParameters_ScalingAlgorithm_LINEAR_PROGRAM;
  static inline bool ScalingAlgorithm_IsValid(int value) {
    return GlopParameters_ScalingAlgorithm_IsValid(value);
  }
  static const ScalingAlgorithm ScalingAlgorithm_MIN =
    GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MIN;
  static const ScalingAlgorithm ScalingAlgorithm_MAX =
    GlopParameters_ScalingAlgorithm_ScalingAlgorithm_MAX;
  static const int ScalingAlgorithm_ARRAYSIZE =
    GlopParameters_ScalingAlgorithm_ScalingAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScalingAlgorithm_descriptor() {
    return GlopParameters_ScalingAlgorithm_descriptor();
  }
  static inline const ::std::string& ScalingAlgorithm_Name(ScalingAlgorithm value) {
    return GlopParameters_ScalingAlgorithm_Name(value);
  }
  static inline bool ScalingAlgorithm_Parse(const ::std::string& name,
      ScalingAlgorithm* value) {
    return GlopParameters_ScalingAlgorithm_Parse(name, value);
  }

  typedef GlopParameters_SolverBehavior SolverBehavior;
  static const SolverBehavior ALWAYS_DO =
    GlopParameters_SolverBehavior_ALWAYS_DO;
  static const SolverBehavior NEVER_DO =
    GlopParameters_SolverBehavior_NEVER_DO;
  static const SolverBehavior LET_SOLVER_DECIDE =
    GlopParameters_SolverBehavior_LET_SOLVER_DECIDE;
  static inline bool SolverBehavior_IsValid(int value) {
    return GlopParameters_SolverBehavior_IsValid(value);
  }
  static const SolverBehavior SolverBehavior_MIN =
    GlopParameters_SolverBehavior_SolverBehavior_MIN;
  static const SolverBehavior SolverBehavior_MAX =
    GlopParameters_SolverBehavior_SolverBehavior_MAX;
  static const int SolverBehavior_ARRAYSIZE =
    GlopParameters_SolverBehavior_SolverBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SolverBehavior_descriptor() {
    return GlopParameters_SolverBehavior_descriptor();
  }
  static inline const ::std::string& SolverBehavior_Name(SolverBehavior value) {
    return GlopParameters_SolverBehavior_Name(value);
  }
  static inline bool SolverBehavior_Parse(const ::std::string& name,
      SolverBehavior* value) {
    return GlopParameters_SolverBehavior_Parse(name, value);
  }

  typedef GlopParameters_PricingRule PricingRule;
  static const PricingRule DANTZIG =
    GlopParameters_PricingRule_DANTZIG;
  static const PricingRule STEEPEST_EDGE =
    GlopParameters_PricingRule_STEEPEST_EDGE;
  static const PricingRule DEVEX =
    GlopParameters_PricingRule_DEVEX;
  static inline bool PricingRule_IsValid(int value) {
    return GlopParameters_PricingRule_IsValid(value);
  }
  static const PricingRule PricingRule_MIN =
    GlopParameters_PricingRule_PricingRule_MIN;
  static const PricingRule PricingRule_MAX =
    GlopParameters_PricingRule_PricingRule_MAX;
  static const int PricingRule_ARRAYSIZE =
    GlopParameters_PricingRule_PricingRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PricingRule_descriptor() {
    return GlopParameters_PricingRule_descriptor();
  }
  static inline const ::std::string& PricingRule_Name(PricingRule value) {
    return GlopParameters_PricingRule_Name(value);
  }
  static inline bool PricingRule_Parse(const ::std::string& name,
      PricingRule* value) {
    return GlopParameters_PricingRule_Parse(name, value);
  }

  typedef GlopParameters_InitialBasisHeuristic InitialBasisHeuristic;
  static const InitialBasisHeuristic NONE =
    GlopParameters_InitialBasisHeuristic_NONE;
  static const InitialBasisHeuristic BIXBY =
    GlopParameters_InitialBasisHeuristic_BIXBY;
  static const InitialBasisHeuristic TRIANGULAR =
    GlopParameters_InitialBasisHeuristic_TRIANGULAR;
  static inline bool InitialBasisHeuristic_IsValid(int value) {
    return GlopParameters_InitialBasisHeuristic_IsValid(value);
  }
  static const InitialBasisHeuristic InitialBasisHeuristic_MIN =
    GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MIN;
  static const InitialBasisHeuristic InitialBasisHeuristic_MAX =
    GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_MAX;
  static const int InitialBasisHeuristic_ARRAYSIZE =
    GlopParameters_InitialBasisHeuristic_InitialBasisHeuristic_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InitialBasisHeuristic_descriptor() {
    return GlopParameters_InitialBasisHeuristic_descriptor();
  }
  static inline const ::std::string& InitialBasisHeuristic_Name(InitialBasisHeuristic value) {
    return GlopParameters_InitialBasisHeuristic_Name(value);
  }
  static inline bool InitialBasisHeuristic_Parse(const ::std::string& name,
      InitialBasisHeuristic* value) {
    return GlopParameters_InitialBasisHeuristic_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool use_dual_simplex = 31 [default = false];
  bool has_use_dual_simplex() const;
  void clear_use_dual_simplex();
  static const int kUseDualSimplexFieldNumber = 31;
  bool use_dual_simplex() const;
  void set_use_dual_simplex(bool value);

  // optional bool allow_simplex_algorithm_change = 32 [default = false];
  bool has_allow_simplex_algorithm_change() const;
  void clear_allow_simplex_algorithm_change();
  static const int kAllowSimplexAlgorithmChangeFieldNumber = 32;
  bool allow_simplex_algorithm_change() const;
  void set_allow_simplex_algorithm_change(bool value);

  // optional bool use_solowhalim = 46 [default = false];
  bool has_use_solowhalim() const;
  void clear_use_solowhalim();
  static const int kUseSolowhalimFieldNumber = 46;
  bool use_solowhalim() const;
  void set_use_solowhalim(bool value);

  // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
  bool has_perturb_costs_in_dual_simplex() const;
  void clear_perturb_costs_in_dual_simplex();
  static const int kPerturbCostsInDualSimplexFieldNumber = 53;
  bool perturb_costs_in_dual_simplex() const;
  void set_perturb_costs_in_dual_simplex(bool value);

  // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
  bool has_scaling_method() const;
  void clear_scaling_method();
  static const int kScalingMethodFieldNumber = 57;
  ::operations_research::glop::GlopParameters_ScalingAlgorithm scaling_method() const;
  void set_scaling_method(::operations_research::glop::GlopParameters_ScalingAlgorithm value);

  // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
  bool has_feasibility_rule() const;
  void clear_feasibility_rule();
  static const int kFeasibilityRuleFieldNumber = 1;
  ::operations_research::glop::GlopParameters_PricingRule feasibility_rule() const;
  void set_feasibility_rule(::operations_research::glop::GlopParameters_PricingRule value);

  // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
  bool has_optimization_rule() const;
  void clear_optimization_rule();
  static const int kOptimizationRuleFieldNumber = 2;
  ::operations_research::glop::GlopParameters_PricingRule optimization_rule() const;
  void set_optimization_rule(::operations_research::glop::GlopParameters_PricingRule value);

  // optional double refactorization_threshold = 6 [default = 1e-09];
  bool has_refactorization_threshold() const;
  void clear_refactorization_threshold();
  static const int kRefactorizationThresholdFieldNumber = 6;
  double refactorization_threshold() const;
  void set_refactorization_threshold(double value);

  // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
  bool has_recompute_reduced_costs_threshold() const;
  void clear_recompute_reduced_costs_threshold();
  static const int kRecomputeReducedCostsThresholdFieldNumber = 8;
  double recompute_reduced_costs_threshold() const;
  void set_recompute_reduced_costs_threshold(double value);

  // optional double recompute_edges_norm_threshold = 9 [default = 100];
  bool has_recompute_edges_norm_threshold() const;
  void clear_recompute_edges_norm_threshold();
  static const int kRecomputeEdgesNormThresholdFieldNumber = 9;
  double recompute_edges_norm_threshold() const;
  void set_recompute_edges_norm_threshold(double value);

  // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
  bool has_primal_feasibility_tolerance() const;
  void clear_primal_feasibility_tolerance();
  static const int kPrimalFeasibilityToleranceFieldNumber = 10;
  double primal_feasibility_tolerance() const;
  void set_primal_feasibility_tolerance(double value);

  // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
  bool has_dual_feasibility_tolerance() const;
  void clear_dual_feasibility_tolerance();
  static const int kDualFeasibilityToleranceFieldNumber = 11;
  double dual_feasibility_tolerance() const;
  void set_dual_feasibility_tolerance(double value);

  // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
  bool has_ratio_test_zero_threshold() const;
  void clear_ratio_test_zero_threshold();
  static const int kRatioTestZeroThresholdFieldNumber = 12;
  double ratio_test_zero_threshold() const;
  void set_ratio_test_zero_threshold(double value);

  // optional bool normalize_using_column_norm = 4 [default = true];
  bool has_normalize_using_column_norm() const;
  void clear_normalize_using_column_norm();
  static const int kNormalizeUsingColumnNormFieldNumber = 4;
  bool normalize_using_column_norm() const;
  void set_normalize_using_column_norm(bool value);

  // optional bool use_nested_pricing = 5 [default = true];
  bool has_use_nested_pricing() const;
  void clear_use_nested_pricing();
  static const int kUseNestedPricingFieldNumber = 5;
  bool use_nested_pricing() const;
  void set_use_nested_pricing(bool value);

  // optional bool use_scaling = 16 [default = true];
  bool has_use_scaling() const;
  void clear_use_scaling();
  static const int kUseScalingFieldNumber = 16;
  bool use_scaling() const;
  void set_use_scaling(bool value);

  // optional bool use_transposed_matrix = 18 [default = true];
  bool has_use_transposed_matrix() const;
  void clear_use_transposed_matrix();
  static const int kUseTransposedMatrixFieldNumber = 18;
  bool use_transposed_matrix() const;
  void set_use_transposed_matrix(bool value);

  // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
  bool has_initial_basis() const;
  void clear_initial_basis();
  static const int kInitialBasisFieldNumber = 17;
  ::operations_research::glop::GlopParameters_InitialBasisHeuristic initial_basis() const;
  void set_initial_basis(::operations_research::glop::GlopParameters_InitialBasisHeuristic value);

  // optional double harris_tolerance_ratio = 13 [default = 0.5];
  bool has_harris_tolerance_ratio() const;
  void clear_harris_tolerance_ratio();
  static const int kHarrisToleranceRatioFieldNumber = 13;
  double harris_tolerance_ratio() const;
  void set_harris_tolerance_ratio(double value);

  // optional double small_pivot_threshold = 14 [default = 1e-06];
  bool has_small_pivot_threshold() const;
  void clear_small_pivot_threshold();
  static const int kSmallPivotThresholdFieldNumber = 14;
  double small_pivot_threshold() const;
  void set_small_pivot_threshold(double value);

  // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
  bool has_minimum_acceptable_pivot() const;
  void clear_minimum_acceptable_pivot();
  static const int kMinimumAcceptablePivotFieldNumber = 15;
  double minimum_acceptable_pivot() const;
  void set_minimum_acceptable_pivot(double value);

  // optional int32 basis_refactorization_period = 19 [default = 64];
  bool has_basis_refactorization_period() const;
  void clear_basis_refactorization_period();
  static const int kBasisRefactorizationPeriodFieldNumber = 19;
  ::google::protobuf::int32 basis_refactorization_period() const;
  void set_basis_refactorization_period(::google::protobuf::int32 value);

  // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
  bool has_solve_dual_problem() const;
  void clear_solve_dual_problem();
  static const int kSolveDualProblemFieldNumber = 20;
  ::operations_research::glop::GlopParameters_SolverBehavior solve_dual_problem() const;
  void set_solve_dual_problem(::operations_research::glop::GlopParameters_SolverBehavior value);

  // optional double dualizer_threshold = 21 [default = 1.5];
  bool has_dualizer_threshold() const;
  void clear_dualizer_threshold();
  static const int kDualizerThresholdFieldNumber = 21;
  double dualizer_threshold() const;
  void set_dualizer_threshold(double value);

  // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
  bool has_solution_feasibility_tolerance() const;
  void clear_solution_feasibility_tolerance();
  static const int kSolutionFeasibilityToleranceFieldNumber = 22;
  double solution_feasibility_tolerance() const;
  void set_solution_feasibility_tolerance(double value);

  // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
  bool has_lu_factorization_pivot_threshold() const;
  void clear_lu_factorization_pivot_threshold();
  static const int kLuFactorizationPivotThresholdFieldNumber = 25;
  double lu_factorization_pivot_threshold() const;
  void set_lu_factorization_pivot_threshold(double value);

  // optional double max_time_in_seconds = 26 [default = inf];
  bool has_max_time_in_seconds() const;
  void clear_max_time_in_seconds();
  static const int kMaxTimeInSecondsFieldNumber = 26;
  double max_time_in_seconds() const;
  void set_max_time_in_seconds(double value);

  // optional int64 max_number_of_iterations = 27 [default = -1];
  bool has_max_number_of_iterations() const;
  void clear_max_number_of_iterations();
  static const int kMaxNumberOfIterationsFieldNumber = 27;
  ::google::protobuf::int64 max_number_of_iterations() const;
  void set_max_number_of_iterations(::google::protobuf::int64 value);

  // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
  bool has_markowitz_singularity_threshold() const;
  void clear_markowitz_singularity_threshold();
  static const int kMarkowitzSingularityThresholdFieldNumber = 30;
  double markowitz_singularity_threshold() const;
  void set_markowitz_singularity_threshold(double value);

  // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
  bool has_markowitz_zlatev_parameter() const;
  void clear_markowitz_zlatev_parameter();
  static const int kMarkowitzZlatevParameterFieldNumber = 29;
  ::google::protobuf::int32 markowitz_zlatev_parameter() const;
  void set_markowitz_zlatev_parameter(::google::protobuf::int32 value);

  // optional bool provide_strong_optimal_guarantee = 24 [default = true];
  bool has_provide_strong_optimal_guarantee() const;
  void clear_provide_strong_optimal_guarantee();
  static const int kProvideStrongOptimalGuaranteeFieldNumber = 24;
  bool provide_strong_optimal_guarantee() const;
  void set_provide_strong_optimal_guarantee(bool value);

  // optional bool use_preprocessing = 34 [default = true];
  bool has_use_preprocessing() const;
  void clear_use_preprocessing();
  static const int kUsePreprocessingFieldNumber = 34;
  bool use_preprocessing() const;
  void set_use_preprocessing(bool value);

  // optional bool use_middle_product_form_update = 35 [default = true];
  bool has_use_middle_product_form_update() const;
  void clear_use_middle_product_form_update();
  static const int kUseMiddleProductFormUpdateFieldNumber = 35;
  bool use_middle_product_form_update() const;
  void set_use_middle_product_form_update(bool value);

  // optional bool initialize_devex_with_column_norms = 36 [default = true];
  bool has_initialize_devex_with_column_norms() const;
  void clear_initialize_devex_with_column_norms();
  static const int kInitializeDevexWithColumnNormsFieldNumber = 36;
  bool initialize_devex_with_column_norms() const;
  void set_initialize_devex_with_column_norms(bool value);

  // optional int32 devex_weights_reset_period = 33 [default = 150];
  bool has_devex_weights_reset_period() const;
  void clear_devex_weights_reset_period();
  static const int kDevexWeightsResetPeriodFieldNumber = 33;
  ::google::protobuf::int32 devex_weights_reset_period() const;
  void set_devex_weights_reset_period(::google::protobuf::int32 value);

  // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
  bool has_exploit_singleton_column_in_initial_basis() const;
  void clear_exploit_singleton_column_in_initial_basis();
  static const int kExploitSingletonColumnInInitialBasisFieldNumber = 37;
  bool exploit_singleton_column_in_initial_basis() const;
  void set_exploit_singleton_column_in_initial_basis(bool value);

  // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
  bool has_dual_small_pivot_threshold() const;
  void clear_dual_small_pivot_threshold();
  static const int kDualSmallPivotThresholdFieldNumber = 38;
  double dual_small_pivot_threshold() const;
  void set_dual_small_pivot_threshold(double value);

  // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
  bool has_preprocessor_zero_tolerance() const;
  void clear_preprocessor_zero_tolerance();
  static const int kPreprocessorZeroToleranceFieldNumber = 39;
  double preprocessor_zero_tolerance() const;
  void set_preprocessor_zero_tolerance(double value);

  // optional double objective_lower_limit = 40 [default = -inf];
  bool has_objective_lower_limit() const;
  void clear_objective_lower_limit();
  static const int kObjectiveLowerLimitFieldNumber = 40;
  double objective_lower_limit() const;
  void set_objective_lower_limit(double value);

  // optional double objective_upper_limit = 41 [default = inf];
  bool has_objective_upper_limit() const;
  void clear_objective_upper_limit();
  static const int kObjectiveUpperLimitFieldNumber = 41;
  double objective_upper_limit() const;
  void set_objective_upper_limit(double value);

  // optional double degenerate_ministep_factor = 42 [default = 0.01];
  bool has_degenerate_ministep_factor() const;
  void clear_degenerate_ministep_factor();
  static const int kDegenerateMinistepFactorFieldNumber = 42;
  double degenerate_ministep_factor() const;
  void set_degenerate_ministep_factor(double value);

  // optional int32 random_seed = 43 [default = 1];
  bool has_random_seed() const;
  void clear_random_seed();
  static const int kRandomSeedFieldNumber = 43;
  ::google::protobuf::int32 random_seed() const;
  void set_random_seed(::google::protobuf::int32 value);

  // optional int32 num_omp_threads = 44 [default = 1];
  bool has_num_omp_threads() const;
  void clear_num_omp_threads();
  static const int kNumOmpThreadsFieldNumber = 44;
  ::google::protobuf::int32 num_omp_threads() const;
  void set_num_omp_threads(::google::protobuf::int32 value);

  // optional double max_deterministic_time = 45 [default = inf];
  bool has_max_deterministic_time() const;
  void clear_max_deterministic_time();
  static const int kMaxDeterministicTimeFieldNumber = 45;
  double max_deterministic_time() const;
  void set_max_deterministic_time(double value);

  // optional double drop_tolerance = 52 [default = 1e-14];
  bool has_drop_tolerance() const;
  void clear_drop_tolerance();
  static const int kDropToleranceFieldNumber = 52;
  double drop_tolerance() const;
  void set_drop_tolerance(double value);

  // optional double relative_cost_perturbation = 54 [default = 1e-05];
  bool has_relative_cost_perturbation() const;
  void clear_relative_cost_perturbation();
  static const int kRelativeCostPerturbationFieldNumber = 54;
  double relative_cost_perturbation() const;
  void set_relative_cost_perturbation(double value);

  // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
  bool has_relative_max_cost_perturbation() const;
  void clear_relative_max_cost_perturbation();
  static const int kRelativeMaxCostPerturbationFieldNumber = 55;
  double relative_max_cost_perturbation() const;
  void set_relative_max_cost_perturbation(double value);

  // optional double max_number_of_reoptimizations = 56 [default = 40];
  bool has_max_number_of_reoptimizations() const;
  void clear_max_number_of_reoptimizations();
  static const int kMaxNumberOfReoptimizationsFieldNumber = 56;
  double max_number_of_reoptimizations() const;
  void set_max_number_of_reoptimizations(double value);

  // @@protoc_insertion_point(class_scope:operations_research.glop.GlopParameters)
 private:
  void set_has_scaling_method();
  void clear_has_scaling_method();
  void set_has_feasibility_rule();
  void clear_has_feasibility_rule();
  void set_has_optimization_rule();
  void clear_has_optimization_rule();
  void set_has_normalize_using_column_norm();
  void clear_has_normalize_using_column_norm();
  void set_has_use_nested_pricing();
  void clear_has_use_nested_pricing();
  void set_has_refactorization_threshold();
  void clear_has_refactorization_threshold();
  void set_has_recompute_reduced_costs_threshold();
  void clear_has_recompute_reduced_costs_threshold();
  void set_has_recompute_edges_norm_threshold();
  void clear_has_recompute_edges_norm_threshold();
  void set_has_primal_feasibility_tolerance();
  void clear_has_primal_feasibility_tolerance();
  void set_has_dual_feasibility_tolerance();
  void clear_has_dual_feasibility_tolerance();
  void set_has_ratio_test_zero_threshold();
  void clear_has_ratio_test_zero_threshold();
  void set_has_harris_tolerance_ratio();
  void clear_has_harris_tolerance_ratio();
  void set_has_small_pivot_threshold();
  void clear_has_small_pivot_threshold();
  void set_has_minimum_acceptable_pivot();
  void clear_has_minimum_acceptable_pivot();
  void set_has_drop_tolerance();
  void clear_has_drop_tolerance();
  void set_has_use_scaling();
  void clear_has_use_scaling();
  void set_has_initial_basis();
  void clear_has_initial_basis();
  void set_has_use_transposed_matrix();
  void clear_has_use_transposed_matrix();
  void set_has_basis_refactorization_period();
  void clear_has_basis_refactorization_period();
  void set_has_solve_dual_problem();
  void clear_has_solve_dual_problem();
  void set_has_dualizer_threshold();
  void clear_has_dualizer_threshold();
  void set_has_solution_feasibility_tolerance();
  void clear_has_solution_feasibility_tolerance();
  void set_has_provide_strong_optimal_guarantee();
  void clear_has_provide_strong_optimal_guarantee();
  void set_has_max_number_of_reoptimizations();
  void clear_has_max_number_of_reoptimizations();
  void set_has_lu_factorization_pivot_threshold();
  void clear_has_lu_factorization_pivot_threshold();
  void set_has_max_time_in_seconds();
  void clear_has_max_time_in_seconds();
  void set_has_max_deterministic_time();
  void clear_has_max_deterministic_time();
  void set_has_max_number_of_iterations();
  void clear_has_max_number_of_iterations();
  void set_has_markowitz_zlatev_parameter();
  void clear_has_markowitz_zlatev_parameter();
  void set_has_markowitz_singularity_threshold();
  void clear_has_markowitz_singularity_threshold();
  void set_has_use_dual_simplex();
  void clear_has_use_dual_simplex();
  void set_has_allow_simplex_algorithm_change();
  void clear_has_allow_simplex_algorithm_change();
  void set_has_devex_weights_reset_period();
  void clear_has_devex_weights_reset_period();
  void set_has_use_preprocessing();
  void clear_has_use_preprocessing();
  void set_has_use_middle_product_form_update();
  void clear_has_use_middle_product_form_update();
  void set_has_initialize_devex_with_column_norms();
  void clear_has_initialize_devex_with_column_norms();
  void set_has_exploit_singleton_column_in_initial_basis();
  void clear_has_exploit_singleton_column_in_initial_basis();
  void set_has_dual_small_pivot_threshold();
  void clear_has_dual_small_pivot_threshold();
  void set_has_preprocessor_zero_tolerance();
  void clear_has_preprocessor_zero_tolerance();
  void set_has_objective_lower_limit();
  void clear_has_objective_lower_limit();
  void set_has_objective_upper_limit();
  void clear_has_objective_upper_limit();
  void set_has_degenerate_ministep_factor();
  void clear_has_degenerate_ministep_factor();
  void set_has_random_seed();
  void clear_has_random_seed();
  void set_has_num_omp_threads();
  void clear_has_num_omp_threads();
  void set_has_use_solowhalim();
  void clear_has_use_solowhalim();
  void set_has_perturb_costs_in_dual_simplex();
  void clear_has_perturb_costs_in_dual_simplex();
  void set_has_relative_cost_perturbation();
  void clear_has_relative_cost_perturbation();
  void set_has_relative_max_cost_perturbation();
  void clear_has_relative_max_cost_perturbation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  bool use_dual_simplex_;
  bool allow_simplex_algorithm_change_;
  bool use_solowhalim_;
  bool perturb_costs_in_dual_simplex_;
  int scaling_method_;
  int feasibility_rule_;
  int optimization_rule_;
  double refactorization_threshold_;
  double recompute_reduced_costs_threshold_;
  double recompute_edges_norm_threshold_;
  double primal_feasibility_tolerance_;
  double dual_feasibility_tolerance_;
  double ratio_test_zero_threshold_;
  bool normalize_using_column_norm_;
  bool use_nested_pricing_;
  bool use_scaling_;
  bool use_transposed_matrix_;
  int initial_basis_;
  double harris_tolerance_ratio_;
  double small_pivot_threshold_;
  double minimum_acceptable_pivot_;
  ::google::protobuf::int32 basis_refactorization_period_;
  int solve_dual_problem_;
  double dualizer_threshold_;
  double solution_feasibility_tolerance_;
  double lu_factorization_pivot_threshold_;
  double max_time_in_seconds_;
  ::google::protobuf::int64 max_number_of_iterations_;
  double markowitz_singularity_threshold_;
  ::google::protobuf::int32 markowitz_zlatev_parameter_;
  bool provide_strong_optimal_guarantee_;
  bool use_preprocessing_;
  bool use_middle_product_form_update_;
  bool initialize_devex_with_column_norms_;
  ::google::protobuf::int32 devex_weights_reset_period_;
  bool exploit_singleton_column_in_initial_basis_;
  double dual_small_pivot_threshold_;
  double preprocessor_zero_tolerance_;
  double objective_lower_limit_;
  double objective_upper_limit_;
  double degenerate_ministep_factor_;
  ::google::protobuf::int32 random_seed_;
  ::google::protobuf::int32 num_omp_threads_;
  double max_deterministic_time_;
  double drop_tolerance_;
  double relative_cost_perturbation_;
  double relative_max_cost_perturbation_;
  double max_number_of_reoptimizations_;
  mutable int _cached_size_;
  friend struct ::protobuf_ortools_2fglop_2fparameters_2eproto::TableStruct;
  friend void ::protobuf_ortools_2fglop_2fparameters_2eproto::InitDefaultsGlopParametersImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GlopParameters

// optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
inline bool GlopParameters::has_scaling_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GlopParameters::set_has_scaling_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GlopParameters::clear_has_scaling_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GlopParameters::clear_scaling_method() {
  scaling_method_ = 1;
  clear_has_scaling_method();
}
inline ::operations_research::glop::GlopParameters_ScalingAlgorithm GlopParameters::scaling_method() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.scaling_method)
  return static_cast< ::operations_research::glop::GlopParameters_ScalingAlgorithm >(scaling_method_);
}
inline void GlopParameters::set_scaling_method(::operations_research::glop::GlopParameters_ScalingAlgorithm value) {
  assert(::operations_research::glop::GlopParameters_ScalingAlgorithm_IsValid(value));
  set_has_scaling_method();
  scaling_method_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.scaling_method)
}

// optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
inline bool GlopParameters::has_feasibility_rule() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GlopParameters::set_has_feasibility_rule() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GlopParameters::clear_has_feasibility_rule() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GlopParameters::clear_feasibility_rule() {
  feasibility_rule_ = 1;
  clear_has_feasibility_rule();
}
inline ::operations_research::glop::GlopParameters_PricingRule GlopParameters::feasibility_rule() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.feasibility_rule)
  return static_cast< ::operations_research::glop::GlopParameters_PricingRule >(feasibility_rule_);
}
inline void GlopParameters::set_feasibility_rule(::operations_research::glop::GlopParameters_PricingRule value) {
  assert(::operations_research::glop::GlopParameters_PricingRule_IsValid(value));
  set_has_feasibility_rule();
  feasibility_rule_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.feasibility_rule)
}

// optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
inline bool GlopParameters::has_optimization_rule() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GlopParameters::set_has_optimization_rule() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GlopParameters::clear_has_optimization_rule() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GlopParameters::clear_optimization_rule() {
  optimization_rule_ = 1;
  clear_has_optimization_rule();
}
inline ::operations_research::glop::GlopParameters_PricingRule GlopParameters::optimization_rule() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.optimization_rule)
  return static_cast< ::operations_research::glop::GlopParameters_PricingRule >(optimization_rule_);
}
inline void GlopParameters::set_optimization_rule(::operations_research::glop::GlopParameters_PricingRule value) {
  assert(::operations_research::glop::GlopParameters_PricingRule_IsValid(value));
  set_has_optimization_rule();
  optimization_rule_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.optimization_rule)
}

// optional bool normalize_using_column_norm = 4 [default = true];
inline bool GlopParameters::has_normalize_using_column_norm() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GlopParameters::set_has_normalize_using_column_norm() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GlopParameters::clear_has_normalize_using_column_norm() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GlopParameters::clear_normalize_using_column_norm() {
  normalize_using_column_norm_ = true;
  clear_has_normalize_using_column_norm();
}
inline bool GlopParameters::normalize_using_column_norm() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.normalize_using_column_norm)
  return normalize_using_column_norm_;
}
inline void GlopParameters::set_normalize_using_column_norm(bool value) {
  set_has_normalize_using_column_norm();
  normalize_using_column_norm_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.normalize_using_column_norm)
}

// optional bool use_nested_pricing = 5 [default = true];
inline bool GlopParameters::has_use_nested_pricing() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GlopParameters::set_has_use_nested_pricing() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GlopParameters::clear_has_use_nested_pricing() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GlopParameters::clear_use_nested_pricing() {
  use_nested_pricing_ = true;
  clear_has_use_nested_pricing();
}
inline bool GlopParameters::use_nested_pricing() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_nested_pricing)
  return use_nested_pricing_;
}
inline void GlopParameters::set_use_nested_pricing(bool value) {
  set_has_use_nested_pricing();
  use_nested_pricing_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_nested_pricing)
}

// optional double refactorization_threshold = 6 [default = 1e-09];
inline bool GlopParameters::has_refactorization_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GlopParameters::set_has_refactorization_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GlopParameters::clear_has_refactorization_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GlopParameters::clear_refactorization_threshold() {
  refactorization_threshold_ = 1e-09;
  clear_has_refactorization_threshold();
}
inline double GlopParameters::refactorization_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.refactorization_threshold)
  return refactorization_threshold_;
}
inline void GlopParameters::set_refactorization_threshold(double value) {
  set_has_refactorization_threshold();
  refactorization_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.refactorization_threshold)
}

// optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
inline bool GlopParameters::has_recompute_reduced_costs_threshold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GlopParameters::set_has_recompute_reduced_costs_threshold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GlopParameters::clear_has_recompute_reduced_costs_threshold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GlopParameters::clear_recompute_reduced_costs_threshold() {
  recompute_reduced_costs_threshold_ = 1e-08;
  clear_has_recompute_reduced_costs_threshold();
}
inline double GlopParameters::recompute_reduced_costs_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.recompute_reduced_costs_threshold)
  return recompute_reduced_costs_threshold_;
}
inline void GlopParameters::set_recompute_reduced_costs_threshold(double value) {
  set_has_recompute_reduced_costs_threshold();
  recompute_reduced_costs_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.recompute_reduced_costs_threshold)
}

// optional double recompute_edges_norm_threshold = 9 [default = 100];
inline bool GlopParameters::has_recompute_edges_norm_threshold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GlopParameters::set_has_recompute_edges_norm_threshold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GlopParameters::clear_has_recompute_edges_norm_threshold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GlopParameters::clear_recompute_edges_norm_threshold() {
  recompute_edges_norm_threshold_ = 100;
  clear_has_recompute_edges_norm_threshold();
}
inline double GlopParameters::recompute_edges_norm_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.recompute_edges_norm_threshold)
  return recompute_edges_norm_threshold_;
}
inline void GlopParameters::set_recompute_edges_norm_threshold(double value) {
  set_has_recompute_edges_norm_threshold();
  recompute_edges_norm_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.recompute_edges_norm_threshold)
}

// optional double primal_feasibility_tolerance = 10 [default = 1e-08];
inline bool GlopParameters::has_primal_feasibility_tolerance() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GlopParameters::set_has_primal_feasibility_tolerance() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GlopParameters::clear_has_primal_feasibility_tolerance() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GlopParameters::clear_primal_feasibility_tolerance() {
  primal_feasibility_tolerance_ = 1e-08;
  clear_has_primal_feasibility_tolerance();
}
inline double GlopParameters::primal_feasibility_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.primal_feasibility_tolerance)
  return primal_feasibility_tolerance_;
}
inline void GlopParameters::set_primal_feasibility_tolerance(double value) {
  set_has_primal_feasibility_tolerance();
  primal_feasibility_tolerance_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.primal_feasibility_tolerance)
}

// optional double dual_feasibility_tolerance = 11 [default = 1e-08];
inline bool GlopParameters::has_dual_feasibility_tolerance() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GlopParameters::set_has_dual_feasibility_tolerance() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GlopParameters::clear_has_dual_feasibility_tolerance() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GlopParameters::clear_dual_feasibility_tolerance() {
  dual_feasibility_tolerance_ = 1e-08;
  clear_has_dual_feasibility_tolerance();
}
inline double GlopParameters::dual_feasibility_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.dual_feasibility_tolerance)
  return dual_feasibility_tolerance_;
}
inline void GlopParameters::set_dual_feasibility_tolerance(double value) {
  set_has_dual_feasibility_tolerance();
  dual_feasibility_tolerance_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.dual_feasibility_tolerance)
}

// optional double ratio_test_zero_threshold = 12 [default = 1e-09];
inline bool GlopParameters::has_ratio_test_zero_threshold() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GlopParameters::set_has_ratio_test_zero_threshold() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GlopParameters::clear_has_ratio_test_zero_threshold() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GlopParameters::clear_ratio_test_zero_threshold() {
  ratio_test_zero_threshold_ = 1e-09;
  clear_has_ratio_test_zero_threshold();
}
inline double GlopParameters::ratio_test_zero_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.ratio_test_zero_threshold)
  return ratio_test_zero_threshold_;
}
inline void GlopParameters::set_ratio_test_zero_threshold(double value) {
  set_has_ratio_test_zero_threshold();
  ratio_test_zero_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.ratio_test_zero_threshold)
}

// optional double harris_tolerance_ratio = 13 [default = 0.5];
inline bool GlopParameters::has_harris_tolerance_ratio() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GlopParameters::set_has_harris_tolerance_ratio() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GlopParameters::clear_has_harris_tolerance_ratio() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GlopParameters::clear_harris_tolerance_ratio() {
  harris_tolerance_ratio_ = 0.5;
  clear_has_harris_tolerance_ratio();
}
inline double GlopParameters::harris_tolerance_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.harris_tolerance_ratio)
  return harris_tolerance_ratio_;
}
inline void GlopParameters::set_harris_tolerance_ratio(double value) {
  set_has_harris_tolerance_ratio();
  harris_tolerance_ratio_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.harris_tolerance_ratio)
}

// optional double small_pivot_threshold = 14 [default = 1e-06];
inline bool GlopParameters::has_small_pivot_threshold() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GlopParameters::set_has_small_pivot_threshold() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GlopParameters::clear_has_small_pivot_threshold() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GlopParameters::clear_small_pivot_threshold() {
  small_pivot_threshold_ = 1e-06;
  clear_has_small_pivot_threshold();
}
inline double GlopParameters::small_pivot_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.small_pivot_threshold)
  return small_pivot_threshold_;
}
inline void GlopParameters::set_small_pivot_threshold(double value) {
  set_has_small_pivot_threshold();
  small_pivot_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.small_pivot_threshold)
}

// optional double minimum_acceptable_pivot = 15 [default = 1e-06];
inline bool GlopParameters::has_minimum_acceptable_pivot() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GlopParameters::set_has_minimum_acceptable_pivot() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GlopParameters::clear_has_minimum_acceptable_pivot() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GlopParameters::clear_minimum_acceptable_pivot() {
  minimum_acceptable_pivot_ = 1e-06;
  clear_has_minimum_acceptable_pivot();
}
inline double GlopParameters::minimum_acceptable_pivot() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.minimum_acceptable_pivot)
  return minimum_acceptable_pivot_;
}
inline void GlopParameters::set_minimum_acceptable_pivot(double value) {
  set_has_minimum_acceptable_pivot();
  minimum_acceptable_pivot_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.minimum_acceptable_pivot)
}

// optional double drop_tolerance = 52 [default = 1e-14];
inline bool GlopParameters::has_drop_tolerance() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void GlopParameters::set_has_drop_tolerance() {
  _has_bits_[1] |= 0x00001000u;
}
inline void GlopParameters::clear_has_drop_tolerance() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void GlopParameters::clear_drop_tolerance() {
  drop_tolerance_ = 1e-14;
  clear_has_drop_tolerance();
}
inline double GlopParameters::drop_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.drop_tolerance)
  return drop_tolerance_;
}
inline void GlopParameters::set_drop_tolerance(double value) {
  set_has_drop_tolerance();
  drop_tolerance_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.drop_tolerance)
}

// optional bool use_scaling = 16 [default = true];
inline bool GlopParameters::has_use_scaling() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GlopParameters::set_has_use_scaling() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GlopParameters::clear_has_use_scaling() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GlopParameters::clear_use_scaling() {
  use_scaling_ = true;
  clear_has_use_scaling();
}
inline bool GlopParameters::use_scaling() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_scaling)
  return use_scaling_;
}
inline void GlopParameters::set_use_scaling(bool value) {
  set_has_use_scaling();
  use_scaling_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_scaling)
}

// optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
inline bool GlopParameters::has_initial_basis() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GlopParameters::set_has_initial_basis() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GlopParameters::clear_has_initial_basis() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GlopParameters::clear_initial_basis() {
  initial_basis_ = 2;
  clear_has_initial_basis();
}
inline ::operations_research::glop::GlopParameters_InitialBasisHeuristic GlopParameters::initial_basis() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.initial_basis)
  return static_cast< ::operations_research::glop::GlopParameters_InitialBasisHeuristic >(initial_basis_);
}
inline void GlopParameters::set_initial_basis(::operations_research::glop::GlopParameters_InitialBasisHeuristic value) {
  assert(::operations_research::glop::GlopParameters_InitialBasisHeuristic_IsValid(value));
  set_has_initial_basis();
  initial_basis_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.initial_basis)
}

// optional bool use_transposed_matrix = 18 [default = true];
inline bool GlopParameters::has_use_transposed_matrix() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GlopParameters::set_has_use_transposed_matrix() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GlopParameters::clear_has_use_transposed_matrix() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GlopParameters::clear_use_transposed_matrix() {
  use_transposed_matrix_ = true;
  clear_has_use_transposed_matrix();
}
inline bool GlopParameters::use_transposed_matrix() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_transposed_matrix)
  return use_transposed_matrix_;
}
inline void GlopParameters::set_use_transposed_matrix(bool value) {
  set_has_use_transposed_matrix();
  use_transposed_matrix_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_transposed_matrix)
}

// optional int32 basis_refactorization_period = 19 [default = 64];
inline bool GlopParameters::has_basis_refactorization_period() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GlopParameters::set_has_basis_refactorization_period() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GlopParameters::clear_has_basis_refactorization_period() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GlopParameters::clear_basis_refactorization_period() {
  basis_refactorization_period_ = 64;
  clear_has_basis_refactorization_period();
}
inline ::google::protobuf::int32 GlopParameters::basis_refactorization_period() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.basis_refactorization_period)
  return basis_refactorization_period_;
}
inline void GlopParameters::set_basis_refactorization_period(::google::protobuf::int32 value) {
  set_has_basis_refactorization_period();
  basis_refactorization_period_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.basis_refactorization_period)
}

// optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
inline bool GlopParameters::has_solve_dual_problem() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GlopParameters::set_has_solve_dual_problem() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GlopParameters::clear_has_solve_dual_problem() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GlopParameters::clear_solve_dual_problem() {
  solve_dual_problem_ = 2;
  clear_has_solve_dual_problem();
}
inline ::operations_research::glop::GlopParameters_SolverBehavior GlopParameters::solve_dual_problem() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.solve_dual_problem)
  return static_cast< ::operations_research::glop::GlopParameters_SolverBehavior >(solve_dual_problem_);
}
inline void GlopParameters::set_solve_dual_problem(::operations_research::glop::GlopParameters_SolverBehavior value) {
  assert(::operations_research::glop::GlopParameters_SolverBehavior_IsValid(value));
  set_has_solve_dual_problem();
  solve_dual_problem_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.solve_dual_problem)
}

// optional double dualizer_threshold = 21 [default = 1.5];
inline bool GlopParameters::has_dualizer_threshold() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GlopParameters::set_has_dualizer_threshold() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GlopParameters::clear_has_dualizer_threshold() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GlopParameters::clear_dualizer_threshold() {
  dualizer_threshold_ = 1.5;
  clear_has_dualizer_threshold();
}
inline double GlopParameters::dualizer_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.dualizer_threshold)
  return dualizer_threshold_;
}
inline void GlopParameters::set_dualizer_threshold(double value) {
  set_has_dualizer_threshold();
  dualizer_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.dualizer_threshold)
}

// optional double solution_feasibility_tolerance = 22 [default = 1e-06];
inline bool GlopParameters::has_solution_feasibility_tolerance() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GlopParameters::set_has_solution_feasibility_tolerance() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GlopParameters::clear_has_solution_feasibility_tolerance() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GlopParameters::clear_solution_feasibility_tolerance() {
  solution_feasibility_tolerance_ = 1e-06;
  clear_has_solution_feasibility_tolerance();
}
inline double GlopParameters::solution_feasibility_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.solution_feasibility_tolerance)
  return solution_feasibility_tolerance_;
}
inline void GlopParameters::set_solution_feasibility_tolerance(double value) {
  set_has_solution_feasibility_tolerance();
  solution_feasibility_tolerance_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.solution_feasibility_tolerance)
}

// optional bool provide_strong_optimal_guarantee = 24 [default = true];
inline bool GlopParameters::has_provide_strong_optimal_guarantee() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void GlopParameters::set_has_provide_strong_optimal_guarantee() {
  _has_bits_[0] |= 0x40000000u;
}
inline void GlopParameters::clear_has_provide_strong_optimal_guarantee() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void GlopParameters::clear_provide_strong_optimal_guarantee() {
  provide_strong_optimal_guarantee_ = true;
  clear_has_provide_strong_optimal_guarantee();
}
inline bool GlopParameters::provide_strong_optimal_guarantee() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.provide_strong_optimal_guarantee)
  return provide_strong_optimal_guarantee_;
}
inline void GlopParameters::set_provide_strong_optimal_guarantee(bool value) {
  set_has_provide_strong_optimal_guarantee();
  provide_strong_optimal_guarantee_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.provide_strong_optimal_guarantee)
}

// optional double max_number_of_reoptimizations = 56 [default = 40];
inline bool GlopParameters::has_max_number_of_reoptimizations() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void GlopParameters::set_has_max_number_of_reoptimizations() {
  _has_bits_[1] |= 0x00008000u;
}
inline void GlopParameters::clear_has_max_number_of_reoptimizations() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void GlopParameters::clear_max_number_of_reoptimizations() {
  max_number_of_reoptimizations_ = 40;
  clear_has_max_number_of_reoptimizations();
}
inline double GlopParameters::max_number_of_reoptimizations() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_number_of_reoptimizations)
  return max_number_of_reoptimizations_;
}
inline void GlopParameters::set_max_number_of_reoptimizations(double value) {
  set_has_max_number_of_reoptimizations();
  max_number_of_reoptimizations_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_number_of_reoptimizations)
}

// optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
inline bool GlopParameters::has_lu_factorization_pivot_threshold() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GlopParameters::set_has_lu_factorization_pivot_threshold() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GlopParameters::clear_has_lu_factorization_pivot_threshold() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GlopParameters::clear_lu_factorization_pivot_threshold() {
  lu_factorization_pivot_threshold_ = 0.01;
  clear_has_lu_factorization_pivot_threshold();
}
inline double GlopParameters::lu_factorization_pivot_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.lu_factorization_pivot_threshold)
  return lu_factorization_pivot_threshold_;
}
inline void GlopParameters::set_lu_factorization_pivot_threshold(double value) {
  set_has_lu_factorization_pivot_threshold();
  lu_factorization_pivot_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.lu_factorization_pivot_threshold)
}

// optional double max_time_in_seconds = 26 [default = inf];
inline bool GlopParameters::has_max_time_in_seconds() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GlopParameters::set_has_max_time_in_seconds() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GlopParameters::clear_has_max_time_in_seconds() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GlopParameters::clear_max_time_in_seconds() {
  max_time_in_seconds_ = ::google::protobuf::internal::Infinity();
  clear_has_max_time_in_seconds();
}
inline double GlopParameters::max_time_in_seconds() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_time_in_seconds)
  return max_time_in_seconds_;
}
inline void GlopParameters::set_max_time_in_seconds(double value) {
  set_has_max_time_in_seconds();
  max_time_in_seconds_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_time_in_seconds)
}

// optional double max_deterministic_time = 45 [default = inf];
inline bool GlopParameters::has_max_deterministic_time() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void GlopParameters::set_has_max_deterministic_time() {
  _has_bits_[1] |= 0x00000800u;
}
inline void GlopParameters::clear_has_max_deterministic_time() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void GlopParameters::clear_max_deterministic_time() {
  max_deterministic_time_ = ::google::protobuf::internal::Infinity();
  clear_has_max_deterministic_time();
}
inline double GlopParameters::max_deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_deterministic_time)
  return max_deterministic_time_;
}
inline void GlopParameters::set_max_deterministic_time(double value) {
  set_has_max_deterministic_time();
  max_deterministic_time_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_deterministic_time)
}

// optional int64 max_number_of_iterations = 27 [default = -1];
inline bool GlopParameters::has_max_number_of_iterations() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GlopParameters::set_has_max_number_of_iterations() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GlopParameters::clear_has_max_number_of_iterations() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GlopParameters::clear_max_number_of_iterations() {
  max_number_of_iterations_ = GOOGLE_LONGLONG(-1);
  clear_has_max_number_of_iterations();
}
inline ::google::protobuf::int64 GlopParameters::max_number_of_iterations() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.max_number_of_iterations)
  return max_number_of_iterations_;
}
inline void GlopParameters::set_max_number_of_iterations(::google::protobuf::int64 value) {
  set_has_max_number_of_iterations();
  max_number_of_iterations_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.max_number_of_iterations)
}

// optional int32 markowitz_zlatev_parameter = 29 [default = 3];
inline bool GlopParameters::has_markowitz_zlatev_parameter() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void GlopParameters::set_has_markowitz_zlatev_parameter() {
  _has_bits_[0] |= 0x20000000u;
}
inline void GlopParameters::clear_has_markowitz_zlatev_parameter() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void GlopParameters::clear_markowitz_zlatev_parameter() {
  markowitz_zlatev_parameter_ = 3;
  clear_has_markowitz_zlatev_parameter();
}
inline ::google::protobuf::int32 GlopParameters::markowitz_zlatev_parameter() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.markowitz_zlatev_parameter)
  return markowitz_zlatev_parameter_;
}
inline void GlopParameters::set_markowitz_zlatev_parameter(::google::protobuf::int32 value) {
  set_has_markowitz_zlatev_parameter();
  markowitz_zlatev_parameter_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.markowitz_zlatev_parameter)
}

// optional double markowitz_singularity_threshold = 30 [default = 1e-15];
inline bool GlopParameters::has_markowitz_singularity_threshold() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GlopParameters::set_has_markowitz_singularity_threshold() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GlopParameters::clear_has_markowitz_singularity_threshold() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GlopParameters::clear_markowitz_singularity_threshold() {
  markowitz_singularity_threshold_ = 1e-15;
  clear_has_markowitz_singularity_threshold();
}
inline double GlopParameters::markowitz_singularity_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.markowitz_singularity_threshold)
  return markowitz_singularity_threshold_;
}
inline void GlopParameters::set_markowitz_singularity_threshold(double value) {
  set_has_markowitz_singularity_threshold();
  markowitz_singularity_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.markowitz_singularity_threshold)
}

// optional bool use_dual_simplex = 31 [default = false];
inline bool GlopParameters::has_use_dual_simplex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlopParameters::set_has_use_dual_simplex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlopParameters::clear_has_use_dual_simplex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlopParameters::clear_use_dual_simplex() {
  use_dual_simplex_ = false;
  clear_has_use_dual_simplex();
}
inline bool GlopParameters::use_dual_simplex() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_dual_simplex)
  return use_dual_simplex_;
}
inline void GlopParameters::set_use_dual_simplex(bool value) {
  set_has_use_dual_simplex();
  use_dual_simplex_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_dual_simplex)
}

// optional bool allow_simplex_algorithm_change = 32 [default = false];
inline bool GlopParameters::has_allow_simplex_algorithm_change() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlopParameters::set_has_allow_simplex_algorithm_change() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlopParameters::clear_has_allow_simplex_algorithm_change() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlopParameters::clear_allow_simplex_algorithm_change() {
  allow_simplex_algorithm_change_ = false;
  clear_has_allow_simplex_algorithm_change();
}
inline bool GlopParameters::allow_simplex_algorithm_change() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.allow_simplex_algorithm_change)
  return allow_simplex_algorithm_change_;
}
inline void GlopParameters::set_allow_simplex_algorithm_change(bool value) {
  set_has_allow_simplex_algorithm_change();
  allow_simplex_algorithm_change_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.allow_simplex_algorithm_change)
}

// optional int32 devex_weights_reset_period = 33 [default = 150];
inline bool GlopParameters::has_devex_weights_reset_period() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void GlopParameters::set_has_devex_weights_reset_period() {
  _has_bits_[1] |= 0x00000004u;
}
inline void GlopParameters::clear_has_devex_weights_reset_period() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void GlopParameters::clear_devex_weights_reset_period() {
  devex_weights_reset_period_ = 150;
  clear_has_devex_weights_reset_period();
}
inline ::google::protobuf::int32 GlopParameters::devex_weights_reset_period() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.devex_weights_reset_period)
  return devex_weights_reset_period_;
}
inline void GlopParameters::set_devex_weights_reset_period(::google::protobuf::int32 value) {
  set_has_devex_weights_reset_period();
  devex_weights_reset_period_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.devex_weights_reset_period)
}

// optional bool use_preprocessing = 34 [default = true];
inline bool GlopParameters::has_use_preprocessing() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void GlopParameters::set_has_use_preprocessing() {
  _has_bits_[0] |= 0x80000000u;
}
inline void GlopParameters::clear_has_use_preprocessing() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void GlopParameters::clear_use_preprocessing() {
  use_preprocessing_ = true;
  clear_has_use_preprocessing();
}
inline bool GlopParameters::use_preprocessing() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_preprocessing)
  return use_preprocessing_;
}
inline void GlopParameters::set_use_preprocessing(bool value) {
  set_has_use_preprocessing();
  use_preprocessing_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_preprocessing)
}

// optional bool use_middle_product_form_update = 35 [default = true];
inline bool GlopParameters::has_use_middle_product_form_update() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void GlopParameters::set_has_use_middle_product_form_update() {
  _has_bits_[1] |= 0x00000001u;
}
inline void GlopParameters::clear_has_use_middle_product_form_update() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void GlopParameters::clear_use_middle_product_form_update() {
  use_middle_product_form_update_ = true;
  clear_has_use_middle_product_form_update();
}
inline bool GlopParameters::use_middle_product_form_update() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_middle_product_form_update)
  return use_middle_product_form_update_;
}
inline void GlopParameters::set_use_middle_product_form_update(bool value) {
  set_has_use_middle_product_form_update();
  use_middle_product_form_update_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_middle_product_form_update)
}

// optional bool initialize_devex_with_column_norms = 36 [default = true];
inline bool GlopParameters::has_initialize_devex_with_column_norms() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void GlopParameters::set_has_initialize_devex_with_column_norms() {
  _has_bits_[1] |= 0x00000002u;
}
inline void GlopParameters::clear_has_initialize_devex_with_column_norms() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void GlopParameters::clear_initialize_devex_with_column_norms() {
  initialize_devex_with_column_norms_ = true;
  clear_has_initialize_devex_with_column_norms();
}
inline bool GlopParameters::initialize_devex_with_column_norms() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.initialize_devex_with_column_norms)
  return initialize_devex_with_column_norms_;
}
inline void GlopParameters::set_initialize_devex_with_column_norms(bool value) {
  set_has_initialize_devex_with_column_norms();
  initialize_devex_with_column_norms_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.initialize_devex_with_column_norms)
}

// optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
inline bool GlopParameters::has_exploit_singleton_column_in_initial_basis() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void GlopParameters::set_has_exploit_singleton_column_in_initial_basis() {
  _has_bits_[1] |= 0x00000008u;
}
inline void GlopParameters::clear_has_exploit_singleton_column_in_initial_basis() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void GlopParameters::clear_exploit_singleton_column_in_initial_basis() {
  exploit_singleton_column_in_initial_basis_ = true;
  clear_has_exploit_singleton_column_in_initial_basis();
}
inline bool GlopParameters::exploit_singleton_column_in_initial_basis() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.exploit_singleton_column_in_initial_basis)
  return exploit_singleton_column_in_initial_basis_;
}
inline void GlopParameters::set_exploit_singleton_column_in_initial_basis(bool value) {
  set_has_exploit_singleton_column_in_initial_basis();
  exploit_singleton_column_in_initial_basis_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.exploit_singleton_column_in_initial_basis)
}

// optional double dual_small_pivot_threshold = 38 [default = 0.0001];
inline bool GlopParameters::has_dual_small_pivot_threshold() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void GlopParameters::set_has_dual_small_pivot_threshold() {
  _has_bits_[1] |= 0x00000010u;
}
inline void GlopParameters::clear_has_dual_small_pivot_threshold() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void GlopParameters::clear_dual_small_pivot_threshold() {
  dual_small_pivot_threshold_ = 0.0001;
  clear_has_dual_small_pivot_threshold();
}
inline double GlopParameters::dual_small_pivot_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.dual_small_pivot_threshold)
  return dual_small_pivot_threshold_;
}
inline void GlopParameters::set_dual_small_pivot_threshold(double value) {
  set_has_dual_small_pivot_threshold();
  dual_small_pivot_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.dual_small_pivot_threshold)
}

// optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
inline bool GlopParameters::has_preprocessor_zero_tolerance() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void GlopParameters::set_has_preprocessor_zero_tolerance() {
  _has_bits_[1] |= 0x00000020u;
}
inline void GlopParameters::clear_has_preprocessor_zero_tolerance() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void GlopParameters::clear_preprocessor_zero_tolerance() {
  preprocessor_zero_tolerance_ = 1e-09;
  clear_has_preprocessor_zero_tolerance();
}
inline double GlopParameters::preprocessor_zero_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.preprocessor_zero_tolerance)
  return preprocessor_zero_tolerance_;
}
inline void GlopParameters::set_preprocessor_zero_tolerance(double value) {
  set_has_preprocessor_zero_tolerance();
  preprocessor_zero_tolerance_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.preprocessor_zero_tolerance)
}

// optional double objective_lower_limit = 40 [default = -inf];
inline bool GlopParameters::has_objective_lower_limit() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void GlopParameters::set_has_objective_lower_limit() {
  _has_bits_[1] |= 0x00000040u;
}
inline void GlopParameters::clear_has_objective_lower_limit() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void GlopParameters::clear_objective_lower_limit() {
  objective_lower_limit_ = -::google::protobuf::internal::Infinity();
  clear_has_objective_lower_limit();
}
inline double GlopParameters::objective_lower_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.objective_lower_limit)
  return objective_lower_limit_;
}
inline void GlopParameters::set_objective_lower_limit(double value) {
  set_has_objective_lower_limit();
  objective_lower_limit_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.objective_lower_limit)
}

// optional double objective_upper_limit = 41 [default = inf];
inline bool GlopParameters::has_objective_upper_limit() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void GlopParameters::set_has_objective_upper_limit() {
  _has_bits_[1] |= 0x00000080u;
}
inline void GlopParameters::clear_has_objective_upper_limit() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void GlopParameters::clear_objective_upper_limit() {
  objective_upper_limit_ = ::google::protobuf::internal::Infinity();
  clear_has_objective_upper_limit();
}
inline double GlopParameters::objective_upper_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.objective_upper_limit)
  return objective_upper_limit_;
}
inline void GlopParameters::set_objective_upper_limit(double value) {
  set_has_objective_upper_limit();
  objective_upper_limit_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.objective_upper_limit)
}

// optional double degenerate_ministep_factor = 42 [default = 0.01];
inline bool GlopParameters::has_degenerate_ministep_factor() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void GlopParameters::set_has_degenerate_ministep_factor() {
  _has_bits_[1] |= 0x00000100u;
}
inline void GlopParameters::clear_has_degenerate_ministep_factor() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void GlopParameters::clear_degenerate_ministep_factor() {
  degenerate_ministep_factor_ = 0.01;
  clear_has_degenerate_ministep_factor();
}
inline double GlopParameters::degenerate_ministep_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.degenerate_ministep_factor)
  return degenerate_ministep_factor_;
}
inline void GlopParameters::set_degenerate_ministep_factor(double value) {
  set_has_degenerate_ministep_factor();
  degenerate_ministep_factor_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.degenerate_ministep_factor)
}

// optional int32 random_seed = 43 [default = 1];
inline bool GlopParameters::has_random_seed() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void GlopParameters::set_has_random_seed() {
  _has_bits_[1] |= 0x00000200u;
}
inline void GlopParameters::clear_has_random_seed() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void GlopParameters::clear_random_seed() {
  random_seed_ = 1;
  clear_has_random_seed();
}
inline ::google::protobuf::int32 GlopParameters::random_seed() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.random_seed)
  return random_seed_;
}
inline void GlopParameters::set_random_seed(::google::protobuf::int32 value) {
  set_has_random_seed();
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.random_seed)
}

// optional int32 num_omp_threads = 44 [default = 1];
inline bool GlopParameters::has_num_omp_threads() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void GlopParameters::set_has_num_omp_threads() {
  _has_bits_[1] |= 0x00000400u;
}
inline void GlopParameters::clear_has_num_omp_threads() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void GlopParameters::clear_num_omp_threads() {
  num_omp_threads_ = 1;
  clear_has_num_omp_threads();
}
inline ::google::protobuf::int32 GlopParameters::num_omp_threads() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.num_omp_threads)
  return num_omp_threads_;
}
inline void GlopParameters::set_num_omp_threads(::google::protobuf::int32 value) {
  set_has_num_omp_threads();
  num_omp_threads_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.num_omp_threads)
}

// optional bool use_solowhalim = 46 [default = false];
inline bool GlopParameters::has_use_solowhalim() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlopParameters::set_has_use_solowhalim() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlopParameters::clear_has_use_solowhalim() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlopParameters::clear_use_solowhalim() {
  use_solowhalim_ = false;
  clear_has_use_solowhalim();
}
inline bool GlopParameters::use_solowhalim() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.use_solowhalim)
  return use_solowhalim_;
}
inline void GlopParameters::set_use_solowhalim(bool value) {
  set_has_use_solowhalim();
  use_solowhalim_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.use_solowhalim)
}

// optional bool perturb_costs_in_dual_simplex = 53 [default = false];
inline bool GlopParameters::has_perturb_costs_in_dual_simplex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GlopParameters::set_has_perturb_costs_in_dual_simplex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GlopParameters::clear_has_perturb_costs_in_dual_simplex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GlopParameters::clear_perturb_costs_in_dual_simplex() {
  perturb_costs_in_dual_simplex_ = false;
  clear_has_perturb_costs_in_dual_simplex();
}
inline bool GlopParameters::perturb_costs_in_dual_simplex() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.perturb_costs_in_dual_simplex)
  return perturb_costs_in_dual_simplex_;
}
inline void GlopParameters::set_perturb_costs_in_dual_simplex(bool value) {
  set_has_perturb_costs_in_dual_simplex();
  perturb_costs_in_dual_simplex_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.perturb_costs_in_dual_simplex)
}

// optional double relative_cost_perturbation = 54 [default = 1e-05];
inline bool GlopParameters::has_relative_cost_perturbation() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void GlopParameters::set_has_relative_cost_perturbation() {
  _has_bits_[1] |= 0x00002000u;
}
inline void GlopParameters::clear_has_relative_cost_perturbation() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void GlopParameters::clear_relative_cost_perturbation() {
  relative_cost_perturbation_ = 1e-05;
  clear_has_relative_cost_perturbation();
}
inline double GlopParameters::relative_cost_perturbation() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.relative_cost_perturbation)
  return relative_cost_perturbation_;
}
inline void GlopParameters::set_relative_cost_perturbation(double value) {
  set_has_relative_cost_perturbation();
  relative_cost_perturbation_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.relative_cost_perturbation)
}

// optional double relative_max_cost_perturbation = 55 [default = 1e-07];
inline bool GlopParameters::has_relative_max_cost_perturbation() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void GlopParameters::set_has_relative_max_cost_perturbation() {
  _has_bits_[1] |= 0x00004000u;
}
inline void GlopParameters::clear_has_relative_max_cost_perturbation() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void GlopParameters::clear_relative_max_cost_perturbation() {
  relative_max_cost_perturbation_ = 1e-07;
  clear_has_relative_max_cost_perturbation();
}
inline double GlopParameters::relative_max_cost_perturbation() const {
  // @@protoc_insertion_point(field_get:operations_research.glop.GlopParameters.relative_max_cost_perturbation)
  return relative_max_cost_perturbation_;
}
inline void GlopParameters::set_relative_max_cost_perturbation(double value) {
  set_has_relative_max_cost_perturbation();
  relative_max_cost_perturbation_ = value;
  // @@protoc_insertion_point(field_set:operations_research.glop.GlopParameters.relative_max_cost_perturbation)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace glop
}  // namespace operations_research

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_ScalingAlgorithm> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_ScalingAlgorithm>() {
  return ::operations_research::glop::GlopParameters_ScalingAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_SolverBehavior> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_SolverBehavior>() {
  return ::operations_research::glop::GlopParameters_SolverBehavior_descriptor();
}
template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_PricingRule> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_PricingRule>() {
  return ::operations_research::glop::GlopParameters_PricingRule_descriptor();
}
template <> struct is_proto_enum< ::operations_research::glop::GlopParameters_InitialBasisHeuristic> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::glop::GlopParameters_InitialBasisHeuristic>() {
  return ::operations_research::glop::GlopParameters_InitialBasisHeuristic_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ortools_2fglop_2fparameters_2eproto__INCLUDED
